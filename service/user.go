package service

import (
	"context"
	"fmt"
	"strings"

	"github.com/davidyap2002/user-go/api"
	config "github.com/davidyap2002/user-go/config"
	model "github.com/davidyap2002/user-go/graph/model"
	tools "github.com/davidyap2002/user-go/tools"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"gorm.io/gorm"
)

//Generated By github.com/davidyap2002/GormCrudGenerator

//UserCreate Create
func UserCreate(ctx context.Context, input model.NewUser) (*model.User, error) {
	checkUser, err := UserGetByEmail(ctx, input.Email, nil)

	if err != gorm.ErrRecordNotFound {
		fmt.Println(err)

		if checkUser != nil {
			return nil, &gqlerror.Error{
				Message: "Email Already Registered",
				Extensions: map[string]interface{}{
					"Code": "Bad Request",
				},
			}
		}
		return nil, err
	}

	emailAvailability, err := api.CheckEmail(ctx, input.Email)

	if err != nil || !emailAvailability {
		fmt.Println(err)
		return nil, err
	}

	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	timeNow := tools.TimeUTC()

	randomHash := tools.RandomHash()
	user := model.User{
		Address:               input.Address,
		Email:                 input.Email,
		Name:                  input.Name,
		Password:              tools.HashPassword(input.Password),
		TelephoneNumber:       input.TelephoneNumber,
		CreatedAt:             timeNow,
		EmailVerificationHash: &randomHash,
	}

	err = db.Table("user").Create(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	_, err = SendEmailVerificationEmail(ctx, input.Email, randomHash)

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &user, nil
}

//UserCreateBatch Create Batch
func UserCreateBatch(ctx context.Context, input []*model.NewUser) ([]*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var userBatch []*model.User
	timeNow := tools.TimeUTC()

	for _, val := range input {
		randomHash := tools.RandomHash()
		user := model.User{
			Address:               val.Address,
			Email:                 val.Email,
			Name:                  val.Name,
			Password:              tools.HashPassword(val.Password),
			TelephoneNumber:       val.TelephoneNumber,
			CreatedAt:             timeNow,
			EmailVerificationHash: &randomHash,
		}

		userBatch = append(userBatch, &user)
	}

	err := db.Table("user").Create(&userBatch).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	for _, val := range userBatch {
		_, err = SendEmailVerificationEmail(ctx, val.Email, *val.EmailVerificationHash)

		if err != nil {
			fmt.Println(err)
			return nil, err
		}
	}

	return userBatch, nil
}

//UserUpdate Update
func UserUpdate(ctx context.Context, input model.UpdateUser) (*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	timeNow := tools.TimeUTC()
	user := model.User{
		Address:                 input.Address,
		EmailVerificationHash:   input.EmailVerificationHash,
		Email:                   input.Email,
		ID:                      input.ID,
		Name:                    input.Name,
		Password:                input.Password,
		TelephoneNumber:         input.TelephoneNumber,
		EmailVerificationStatus: input.EmailVerificationStatus,

		UpdatedAt: &timeNow,
	}

	err := db.Table("user").Where("id = ?", input.ID).Updates(map[string]interface{}{
		"address":                   input.Address,
		"email_verification_hash":   input.EmailVerificationHash,
		"email":                     input.Email,
		"id":                        input.ID,
		"name":                      input.Name,
		"password":                  input.Password,
		"telephone_number":          input.TelephoneNumber,
		"email_verification_status": input.EmailVerificationStatus,
		"updated_at":                &timeNow,
	}).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &user, nil
}

//UserSoftDelete Soft Delete
func UserSoftDelete(ctx context.Context, id int) (string, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	timeNow := tools.TimeUTC()
	err := db.Table("user").Where("id = ?", id).Update("deleted_at", timeNow).Error

	if err != nil {
		fmt.Println(err)
		return "Fail", err
	}

	return "Success", nil
}

//UserRestoreDelete Restore Soft Delete
func UserRestoreDelete(ctx context.Context, id int) (string, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	err := db.Table("user").Where("id = ?", id).Update("deleted_at", nil).Error

	if err != nil {
		fmt.Println(err)
		return "Fail", err
	}

	return "Success", nil
}

//UserHardDelete Hard Delete
func UserHardDelete(ctx context.Context, id int) (string, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	err := db.Table("user").Where("id = ?", id).Delete(&model.User{}).Error

	if err != nil {
		fmt.Println(err)
		return "Fail", err
	}

	return "Success", nil
}

//UserGetByID Get By ID
func UserGetByID(ctx context.Context, id int, scopes *bool) (*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var user model.User

	query := db.Table("user")

	tools.DeletedAt(query, scopes)

	err := query.Where("id = ?", id).First(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &user, nil
}

//UserGetByEmail Get By Email
func UserGetByEmail(ctx context.Context, email string, scopes *bool) (*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var user model.User

	query := db.Table("user")

	tools.DeletedAt(query, scopes)

	err := query.Where("lower(email) = ?", strings.ToLower(email)).First(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &user, nil
}

//UserGetAll GetAll
func UserGetAll(ctx context.Context, scopes *bool) ([]*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var user []*model.User

	query := db.Table("user")

	tools.DeletedAt(query, scopes)

	err := query.Find(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return user, nil
}

//UserPagination Pagination
func UserPagination(ctx context.Context, limit *int, page *int, ascending *bool, sortBy *string, scopes *bool) ([]*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var user []*model.User

	query := db.Table("user")

	tools.QueryMaker(query, limit, page, ascending, sortBy, scopes)

	tools.DeletedAt(query, scopes)

	err := query.Find(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return user, nil
}

//UserTotalDataPagination  Total Data Pagination
func UserTotalDataPagination(ctx context.Context, limit *int, page *int, ascending *bool, sortBy *string, scopes *bool) (int, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var count int64

	query := db.Table("user")

	tools.QueryMaker(query, limit, page, ascending, sortBy, scopes)

	tools.DeletedAt(query, scopes)

	err := query.Count(&count).Error

	if err != nil {
		fmt.Println(err)
		return 0, err
	}

	return int(count), nil
}

//UserGetByToken UserGetByToken
func UserGetByToken(ctx context.Context) (*model.User, error) {
	userByToken := ForContext(ctx)

	if userByToken == nil {
		fmt.Println("Invalid Token")
		return nil, &gqlerror.Error{
			Message: "Invalid Token",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATE",
			},
		}
	}

	user, err := UserGetByID(ctx, userByToken.ID, nil)

	if err == gorm.ErrRecordNotFound {
		fmt.Println("User Not Found")
		return nil, &gqlerror.Error{
			Message: "User Not Found",
			Extensions: map[string]interface{}{
				"code": "BAD REQUEST",
			},
		}
	} else if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return user, nil
}

//UserCreateByGoogleID Create User By Google ID
func UserCreateByGoogleID(ctx context.Context, googleID string, name string, email string, locationCode string) (*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	timeNow := tools.TimeUTC()

	randomHash := tools.RandomHash()
	user := model.User{
		GoogleID:              &googleID,
		Name:                  name,
		Email:                 email,
		LocationCode:          &locationCode,
		CreatedAt:             timeNow,
		EmailVerificationHash: &randomHash,
	}

	err := db.Table("user").Create(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	_, err = SendEmailVerificationEmail(ctx, email, randomHash)

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &user, nil
}

//UserGetByGoogleID Get User By Google ID
func UserGetByGoogleID(ctx context.Context, googleID string, scopes *bool) (*model.User, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var user model.User

	query := db.Table("user")

	tools.DeletedAt(query, scopes)

	err := query.Where("google_id = ?", googleID).First(&user).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &user, nil
}

//UserUpdateGoogleByEmail User Update Google Things By Email
func UserUpdateGoogleByEmail(ctx context.Context, googleID string, email string, locationCode string) error {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	// query := db.Table("user")

	// err := query.Where("google_id = ?", googleID).First(&user).Error

	err := db.Table("user").Where("lower(email) = ?", email).Updates(map[string]interface{}{
		"google_id":     googleID,
		"location_code": locationCode,
	}).Error

	if err != nil {
		fmt.Println(err)
		return err
	}

	return nil
}

//UserFindOrCreateByGoogleID Find Or Create By GoogleID
func UserFindOrCreateByGoogleID(ctx context.Context, googleID string, name string, email string, locationCode string) (*model.User, error) {

	scopes := true
	findUser, err := UserGetByEmail(ctx, email, &scopes)

	if err != nil && err != gorm.ErrRecordNotFound {
		fmt.Println(err)
	} else if err == gorm.ErrRecordNotFound || findUser == nil {
		findUser, err = UserCreateByGoogleID(ctx, googleID, name, email, locationCode)

		if err != nil {
			fmt.Println(err)
			return nil, err
		}
	} else if findUser.GoogleID == nil {
		err = UserUpdateGoogleByEmail(ctx, googleID, email, locationCode)

		if err != nil {
			fmt.Println(err)
		}

		findUser.GoogleID = &googleID
	}

	return findUser, nil
}

//UserUpdateEmailVerification User Update Email Verification
func UserUpdateEmailVerification(ctx context.Context, hash string) (string, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	query := db.Table("user").Where("email_verification_hash = ?", hash).Updates(map[string]interface{}{
		"email_verification_status": 1,
		"email_verification_hash":   nil,
	})

	if query.Error != nil {
		fmt.Println(query.Error)
		return "Failed", query.Error
	}

	if query.RowsAffected == 0 {
		fmt.Println("No Hash Found")
		return "Failed", fmt.Errorf("BAD REQUEST")
	}

	return "Success", nil
}
