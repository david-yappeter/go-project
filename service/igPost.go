package service

import (
	"context"
	"fmt"

	config "github.com/davidyap2002/user-go/config"
	model "github.com/davidyap2002/user-go/graph/model"
	tools "github.com/davidyap2002/user-go/tools"
)

//Generated By github.com/david-yappeter/GormCrudGenerator

//IgPostCreate Create
func IgPostCreate(ctx context.Context, input model.NewIgPost) (*model.IgPost, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	timeNow := tools.TimeUTC()
	userID := ForContext(ctx).ID

	igPost := model.IgPost{
		Caption:    input.Caption,
		CreatedAt:  &timeNow,
		UpdatedAt:  nil,
		DeletedAt:  nil,
		IsArchived: 0,
		UserID:     userID,
	}

	err := db.Table("ig_post").Create(&igPost).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	uploadedFile, err := UploadFileBatch(ctx, input.Files)

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	var isPostFiles []*model.NewIgPostFile

	for _, val := range uploadedFile {
		isPostFiles = append(isPostFiles, &model.NewIgPostFile{
			FileID: val.FileID,
			PostID: igPost.ID,
		})
	}

	igPost.Files, err = IgPostFileCreateBatch(ctx, isPostFiles)

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &igPost, nil
}

//IgPostCreateBatch Create Batch
func IgPostCreateBatch(ctx context.Context, input []*model.NewIgPost) ([]*model.IgPost, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var igPostBatch []*model.IgPost

	timeNow := tools.TimeUTC()
	userID := ForContext(ctx).ID

	for _, val := range input {
		igPost := model.IgPost{
			Caption:    val.Caption,
			CreatedAt:  &timeNow,
			UpdatedAt:  nil,
			DeletedAt:  nil,
			IsArchived: 0,
			UserID:     userID,
		}

		igPostBatch = append(igPostBatch, &igPost)
	}

	err := db.Table("ig_post").Create(&igPostBatch).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	for index, val := range input {
		uploadedFile, err := UploadFileBatch(ctx, val.Files)

		if err != nil {
			fmt.Println(err)
			return nil, err
		}

		var isPostFiles []*model.NewIgPostFile

		for _, val := range uploadedFile {
			isPostFiles = append(isPostFiles, &model.NewIgPostFile{
				FileID: val.FileID,
				PostID: igPostBatch[index].ID,
			})
		}

		igPostBatch[index].Files, err = IgPostFileCreateBatch(ctx, isPostFiles)

		if err != nil {
			fmt.Println(err)
			return nil, err
		}
	}

	return igPostBatch, nil
}

//IgPostUpdate Update
func IgPostUpdate(ctx context.Context, input model.UpdateIgPost) (*model.IgPost, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	timeNow := tools.TimeUTC()

	data := map[string]interface{}{
		"id":         input.ID,
		"updated_at": timeNow,
	}

	if input.Caption != nil {
		data["caption"] = *input.Caption
	}
	if input.IsArchived != nil {
		data["is_archived"] = *input.IsArchived
	}

	err := db.Table("ig_post").Where("id = ?", input.ID).Updates(data).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	getIgPost, err := IgPostGetByID(ctx, input.ID)

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return getIgPost, nil
}

//IgPostArchive Archive
func IgPostArchive(ctx context.Context, id int) (string, error) {
	return IgPostUpdateIsArchivedColumn(ctx, id, 1)
}

//IgPostUnarchive UnArchive
func IgPostUnarchive(ctx context.Context, id int) (string, error) {
	return IgPostUpdateIsArchivedColumn(ctx, id, 0)
}

//IgPostUpdateIsArchivedColumn Update is_archived column
func IgPostUpdateIsArchivedColumn(ctx context.Context, id int, isArchived int) (string, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	timeNow := tools.TimeUTC()

	err := db.Table("ig_post").Where("id = ?", id).Updates(map[string]interface{}{
		"is_archived": isArchived,
		"updated_at":  timeNow,
	}).Error

	if err != nil {
		fmt.Println(err)
		return "Failed", err
	}

	return "Success", nil
}

//IgPostSoftDelete Soft Delete
func IgPostSoftDelete(ctx context.Context, id int) (string, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	timeNow := tools.TimeUTC()

	err := db.Table("ig_post").Where("id = ?", id).Update("deleted_at", timeNow).Error

	if err != nil {
		fmt.Println(err)
		return "Failed", err
	}

	return "Success", nil
}

//IgPostRestoreDelete Restore Delete
func IgPostRestoreDelete(ctx context.Context, id int) (string, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	err := db.Table("ig_post").Where("id = ?", id).Update("deleted_at", nil).Error

	if err != nil {
		fmt.Println(err)
		return "Failed", err
	}

	return "Success", nil
}

//IgPostDelete Delete
func IgPostDelete(ctx context.Context, id int) (string, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	err := db.Table("ig_post").Where("id = ?", id).Delete(&model.IgPost{}).Error

	if err != nil {
		fmt.Println(err)
		return "Fail", err
	}

	return "Success", nil
}

//IgPostGetByID Get By ID
func IgPostGetByID(ctx context.Context, id int) (*model.IgPost, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var igPost model.IgPost

	err := db.Table("ig_post").Where("id = ?", id).First(&igPost).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &igPost, nil
}

//IgPostGetAll GetAll
func IgPostGetAll(ctx context.Context) ([]*model.IgPost, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var igPost []*model.IgPost

	err := db.Table("ig_post").Find(&igPost).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return igPost, nil
}

//IgPostPagination Pagination
func IgPostPagination(ctx context.Context, limit *int, page *int, ascending *bool, sortBy *string, scopes *bool) ([]*model.IgPost, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var igPost []*model.IgPost

	query := db.Table("ig_post")

	tools.QueryMaker(query, limit, page, ascending, sortBy, scopes)
	err := query.Find(&igPost).Error

	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	return igPost, nil
}

//IgPostTotalDataPagination  Total Data Pagination
func IgPostTotalDataPagination(ctx context.Context, limit *int, page *int, ascending *bool, sortBy *string, scopes *bool) (int, error) {
	db := config.ConnectGorm()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	var count int64

	query := db.Table("ig_post")

	tools.QueryMaker(query, limit, page, ascending, sortBy, scopes)
	err := query.Count(&count).Error

	if err != nil {
		fmt.Println(err)
		return 0, err
	}

	return int(count), nil
}
